mod error;
use error::HtmlDocError;

struct Node_Id {
    index : usize,
}

struct Html_Tag {
    parent : Node_Id,
    children : Vec<Node_Id>,
    //Html attributes
    tag : String,
    classes : Option<Vec<String>>,
    ids : Option<Vec<String>>,
}

struct Html_Text{
    parent : Node_Id,
    text : String,
}

enum Html_Data {
    Text(Html_Text),
    Tag(Html_Tag),
}


struct Html_Doc {
    ///Contains the information for the html document.
    ///Uses a memory arena to create a graph view.
    nodes : Vec<Html_Data>,
}

impl Html_Doc {
    fn get_node(&self, id : &Node_Id) -> Result<Html_Node_Pointer,HtmlDocError> {
        let index = id.index;
        if index >= self.nodes.len() {
            return Err(HtmlDocError::with_msg("Invalid id."))
        }
        return Html_Node_Pointer
    }
}

struct Html_Node_Pointer <'a> {
    doc : &'a Html_Doc,
    node : &'a Html_Data,
}

impl <'a> Html_Node_Pointer <'a> {

    fn new<'a>(doc : &'a Html_Doc, node : &'a Html_Data) -> Html_Node_Pointer {
        Html_Node_Pointer {doc : doc, node : node}
    }

    fn Parent(&self) -> Option<Html_Node_Pointer> {
        match self.node {
            Html_Data::Text(t) => {
                match t.parent {
                    None => None,
                    Some(id) => self.doc.get_node(id),   
                }
            }
            Html_Data::Tag(t) => {
                match t.parent {
                    None => None,
                    Some(id) => self.doc.get_node(id),   
                }
            }
        }
    }
}
